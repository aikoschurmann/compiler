
fn bin_search_rec(arr: i32[], lo: i32, hi: i32, key: i32) -> i32 {
    if (lo > hi) { return -1; }
    mid: i32 = lo + (hi - lo) / 2;
    if (arr[mid] == key) { return mid; } else {
        if (arr[mid] < key) { return bin_search_rec(arr, mid + 1, hi, key); }
        else { return bin_search_rec(arr, lo, mid - 1, key); }
    }
}

fn main() {
    a: i32[9] = { 1,2,3,4,5,6,7,8,9 };
    idx: i32 = bin_search_rec(a, 0, 8, 7);
}


fn insert_into_sorted(a: i32[], n: i32) {
    if (n <= 1) { return; }
    insert_into_sorted(a, n - 1);
    key: i32 = a[n - 1];
    idx: i32 = n - 1;
    rec_bubble_swap(a, idx, key);
    return;
}
fn rec_bubble_swap(a: i32[], pos: i32, key: i32) {
    if (pos <= 0) { a[0] = key; return; }
    if (a[pos - 1] <= key) { a[pos] = key; return; }
    tmp: i32 = a[pos - 1];
    a[pos] = tmp;
    rec_bubble_swap(a, pos - 1, key);
}
fn insertion_sort(a: i32[], n: i32) {
    if (n <= 1) {
        return;
    }
    insertion_sort(a, n - 1);
    insert_into_sorted(a, n);
}
fn main() {
    arr: i32[7] = { 5,3,8,1,2,7,4 };
    insertion_sort(arr, 7);
}


fn find_max_index(a: i32[], n: i32, i: i32, current_max: i32, current_idx: i32) -> i32 {
    if (i >= n) { return current_idx; }
    if (a[i] > current_max) { return find_max_index(a, n, i + 1, a[i], i); }
    else { return find_max_index(a, n, i + 1, current_max, current_idx); }
}
fn sel_sort_recursive(a: i32[], n: i32) {
    if (n <= 1) {
        return;
    }
    max_idx: i32 = find_max_index(a, n, 0, a[0], 0);
    tmp: i32 = a[max_idx];
    a[max_idx] = a[n - 1];
    a[n - 1] = tmp;
    sel_sort_recursive(a, n - 1);
}
fn main() {
    a: i32[8] = { 9,4,6,1,8,2,7,3 };
    sel_sort_recursive(a, 8);
}


fn partition(a: i32[], lo: i32, hi: i32) -> i32 {
    pivot: i32 = a[hi];
    return partition_rec(a, lo, hi, lo, lo - 1, pivot);
}
fn partition_rec(a: i32[], lo: i32, hi: i32, j: i32, i: i32, pivot: i32) -> i32 {
    if (j >= hi) {
        tmp: i32 = a[i + 1];
        a[i + 1] = a[hi];
        a[hi] = tmp;
        return i + 1;
    }
    if (a[j] <= pivot) {
        i2: i32 = i + 1;
        tmp2: i32 = a[i2];
        a[i2] = a[j];
        a[j] = tmp2;
        return partition_rec(a, lo, hi, j + 1, i2, pivot);
    } else {
        return partition_rec(a, lo, hi, j + 1, i, pivot);
    }
}
fn quicksort(a: i32[], lo: i32, hi: i32) {
    if (lo < hi) {
        p: i32 = partition(a, lo, hi);
        quicksort(a, lo, p - 1);
        quicksort(a, p + 1, hi);
    }
}
fn main() {
    arr: i32[9] = { 30,3,4,20,5,1,17,12,9 };
    quicksort(arr, 0, 8);
}
